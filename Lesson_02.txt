########  LESSON 2  ########

# print(abs(-5))
# print(abs(5))

# print(5 & 3) # побитовое и. умножение в двоичной системе
# print(5 | 3) # побитовое или. сложение в двоичной системе
# print(5 ^ 3) # побитовое исключающее или. такое умножение, в котором 1 - это когда различаются биты, а ноль если не различаются в двоичной системе
# print(5 >> 3) # побитовое деление: 5 разделить на 2 в 3 степени. в двоичной системе
# print(5 << 3) # побитовое умножение: 5 умножить на 2 в 3 степени. в двоичной системе

# print(int('0110', 2)) # перевод из двоичной в десятичную
# print(int('0110', 3)) # перевод из троичной в десятичную и так далее до 36-ти ричной системы

# print(complex(5,6)) # комплексные числа с мнимой единицей

# my_str = 'Vasya Kuralesov'  # str - string - строка
# print(my_str + my_str)
# print(my_str[2]) # s
# print(my_str[0:15:3]) # срез [start:stop:step] # если не задействуются, то можно оставлять не введённым
# print(my_str[::3]) # срез [start:stop:step] от начала до конца с шагом 3
# print(my_str[:-1:]) # срез [start:stop:step] орицательные начинаются с конца
# print(my_str[::-2]) # срез [start:stop:step] орицательные шаги тоже начинаются с конца

# print(len(my_str[:-1:])) # под каким номером последний символ от нуля до конца? В данном примере длина 15 - от 0 до 14(последний номер символа)
# print(my_str.split(' ')) # разделяет слова по пробелу (в данном примере) на такое: ['Vasya', 'Kuralesov'], то есть делает список.НО так писать не надо, если по пробелу, то надо ничего не указывать
# print(my_str.split()) # НО так, как выше писать не надо, если по пробелу, то надо ничего не указывать:

# my_str_1 = 'VaSyA KuraLeSov' # 5 строк лирического отступления:
# print(my_str_1.title()) # приведение текста, чтобы первые буквы были заглавные, а остальные маленькие
# print(my_str_1.capitalize()) # приведение текста, чтобы самая первая буква была заглавная, а остальные маленькие
# print(my_str_1.lower()) # приведение текста - все маленькие
# print(my_str_1.upper()) # приведение текста - все заглавные

# my_list = ['Vasya', 'Kuralesov'] # наоборот, берём список и ...
# print(' '.join(my_list)) # соединение в строку списка через ПРОБЕЛ (можно через что угодно)
# print(my_str.count('a')) # подсчитывает, сколько раз была буква "a"
# print(my_str.find('a')) # выдаёт под каким номером первый раз встречается буква "a" начиная с лева на право
# print(my_str.find('a', 2)) # выдаёт под каким номером встречается буква "a", начиная со второго номера символа
# print(my_str.rfind('a')) # выдаёт под каким номером первый раз встречается буква "a" начиная с права на лево
# print(my_str.rfind('z')) # ответ "-1" означает, что такой буквы не встречается
# print('a' in my_str) # есть ли "а" в введённом тексте
# print('z' in my_str) # есть ли "z" в введённом тексте

# my_str = 'Anastasiya' # неизменяемый формат данных
# my_str[0] = a # будет ошибка
# my_list = ['Peter', 'Vlad', 50, True] # изменяемый формат данных, то есть можно менять в процессе выполнения программы
# my_list [0] = Vova # первое значение в списке изменится
# print((list(my_str))) # разложение в список по символам
# print(','.join(list(my_str))) # обратная предыдущей операция, только все символы через запятую
# print(my_list[3])
# print(my_list[1:3:2]) # тоже работеат [start:stop:step]
# my_list.append(2) # добавление в конец списка любого значения, в данном случае "2"
# my_list.insert(0, 'qwe') # добавление в список любого значения (в данном случае qwe, в данном случае в нулевой символ списка
# my_list.pop() # удаляет из списка последний объект (если пусто в скобках), но не просто удаляет, а можно это в переменную:
# out = my_list.pop(0)
# print(out)
# my_list.reverse() # зеркалит список
# print(my_list.count('Peter')) # подсчитывает сколько раз есть определённый объект в списке
# print(my_list.index('Vlad')) # подсчитывает сколько раз есть определённый объект в списке
# print(50 in my_list) # есть ли определённое слово или число в списке?

# my_tuple = ['Peter', 'Vlad', 50, True, 'qwe'] # tuple - кортеж брат близнец списка, через [] тот же список
# print(my_tuple) # НО КОРТЕЖ ИМЕЕТ НЕИЗМЕНЯЕМЫЙ ТИП ДАННЫХ!!!

# my_tuple = ('Peter', 'Vlad', 50, True, 'qwe') # tuple - кортеж через ()
# print(my_tuple)

# my_tuple = ('Peter', 'Vlad', 50, True, 'qwe')
# print(my_tuple.index('Peter')) # ответ 0 поиск места
# print(my_tuple.count('Peter')) # ответ 1 подсчёт
# print('Peter' in my_tuple) # есть ли петер в списке?
# print(my_tuple[0:5:2]) # срезы тоже работают и со старт стоп степ
# Зачем он? защита от дурака! Занимает меньше памяти!


# my_set = {1,5,2,5,3,2,5,9} # set - вычисление пересечений множеств, можно как командой set, так и собками {}
# print(my_set)

# a = {1, 3, 7, 8}
# b = {2, 4, 8, 3}

# print(a | b) # объединение множеств
# print(a == b) # сравнение множеств
# print(a & b) # пересечение множеств
# print(a - b) # вычитание множеств
# print(a ^ b) # всё, кроме пересечения множеств

# a.remove(3)
# print(a) # из множества а удалить 3, если 3 нет во множестве, то будет ошибка. Множества - изменяемый тип данных

# a.discard(3)
# print(a) # из множества а удалить 3, если 3 нет во множестве, то ошибки не будет, то есть удаляет по тихому

# human = {'name': 'Ivan', 'age': 80, 80: 'qwe'} # словарь
# human['data'] = True
# print(human) # результат: добавляется в словарь так: {'name': 'Uvan', 'age': 80, 80: 'qwe', 'data': True}
# prrint(ABC) # результат - ошибка, так как в структуре словаря нет "АБЦ"
# print(human.get('ABC')) # результат НОН и выполнение не падает в ошибку
# print(human.keys()) # выдаются все ключи словаря
# print(human.values()) # выдаются все значения ключей словаря
# print(human.items()) # выдаётся результат распределённый по всем ключам и их значениям dict_items([('name', 'Ivan'), ('age', 80), (80, 'qwe')])

# out = human.pop('name') # pop вырезает ключ и его значение и запоминает значение ключа в переменную out
# print(human) # выдаёт без name
# print(out) # выдаёт name без названия ключа
# out = human.popitem() # удаление последней пары и можно запомнить в переменную
# print(out)
# print(human)

# СТРОКИ МОЖНО ДНЛИТЬ ПО ЗАПЯТОЙ ENTERом:
# human = {'name': ['Ivan', 'Nikita'],
#          'age': (80, 58),
#          80: 'qwe'} # словарь по парам

# a = 5
# b = 5
# # print(a == b) # True
# print(id(a)) # под каким индексом а расположено в памяти
# print(id(b)) # под каким индексом б расположено в памяти
# print(a is b) # True, так как индексы одинаковые

# a = 5
# b = 6
# # print(a == b) # False
# print(id(a)) # под каким индексом а расположено в памяти
# print(id(b)) # под каким индексом б расположено в памяти
# print(a is b) # False, так как индексы разные

# a = [5]
# b = [5]
# # print(a == b) # True
# print(id(a)) # под каким индексом а расположено в памяти
# print(id(b)) # под каким индексом б расположено в памяти
# print(a is b) # False, так как индексы разные

# a = [5] # диапазон интов вводов от -5 до 256, тогда будут равны точно.
# b = a # если написать b = a.copy(), то изменения а не произойдёт!!!
# b.append(10) # к листу а добавится 10. Изменились и а и б и они равны
# print(a is b) # True Изменились и а и б и они равны
# print(a == b) # True Изменились и а и б и они равны
# print(b) # выйдет [5, 10]


# a = 256
# b = 256
#
# print(a is b) # True
#
# a = 257
# b = 257
#
# print(a is b) # True потому, что PyCharm не разделяет по диапазону от -5 до 256, но питон будет думать по другому
#
# a = -6
# b = -6
#
# print(a is b) # True потому, что PyCharm не разделяет по диапазону от -5 до 256, но питон будет думать по другому


# ТИП ДАННЫХ ИСКЛЮЧЕНИЕ

# print(10 / int(input(': '))) # если ввести 0, то ошибка
# except: уберёт все ошибки

# try:
#     print(10 / int(input(': ')))
# except ZeroDivisionError:   # Исключение ошибки в выполнении программы. Можно таким образом исключить любые ошибки
#     print('Деление на ноль')
# except ValueError:   # Исключение ошибки другой, например ввода текста вместо цифр
#     print('text format')
# finally: # для того, чтобы всё равно выполнялось то, что после finally, не смотря на ошибки выше
#     print('fin')
# print('end programm')


# my_list = ['Anya', 'Vova', 'Petr']
#
# # for name in my_list:
# #     if name == 'Anya':
# #         continue # пропуск АНЯ
# #     print(name)
#
# for name in my_list[2::]: # можно делать срезы старт стоп степ
#     if name == 'Anya':
#         continue # пропуск АНЯ, также можно выполнять break
#     print(name)


# Тернарный оператор

# age = 19
# if age >= 18:
#     print('Welcome!')
# else:
#     print('+18 content')

# по другому:
# age = int(input('What is your age? '))
#
# # print('welcome' if age >= 18 else '+18 content')
#
# access = True if age >= 18 else False
# print('Доступ: ', access)